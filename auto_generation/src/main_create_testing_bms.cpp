#include <iostream>
#include <fstream>
#include <sstream>
#include <cstring>
#include <vector>
#include <cctype>
#include <algorithm>

/* This file autogenerates:
   - one class for each bitmap in the bm json file

   For each bitmap class, it provides:
   -
*/
#include "json.h"
std::string make_classname_format(std::string bm_name) {

    //bm in camel case for class name
    bool capitalize_char = true;
    for (auto & c: bm_name) {
        if (capitalize_char) {
            c = std::toupper(c);
            capitalize_char = false;
        } else if (c == '_') {
            capitalize_char = true;
        }
    }

    // remove underscores
    bm_name.erase(
        std::remove(bm_name.begin(), bm_name.end(), '_'),
        bm_name.end());

    return bm_name;
}

int main() {

    using Json = nlohmann::json;

    std::cout << "bitmap class list" << std::endl;

    // *** BITMAP *** //

    // open and parse the JSON bitmap format
    // bm : bitmap
    // bmf_fs : bitmap format file - file stream

    std::ifstream bmf_fs;
    bmf_fs.open("../bm_format.json");

    if (not bmf_fs) {
        std::cerr << "ERROR: can't open bitmaps format file" << std::endl;
        std::exit(EXIT_FAILURE);
    }

    std::stringstream bmf_ss;
    bmf_ss << bmf_fs.rdbuf();

    Json bmf_json;
    bmf_json = Json::parse(bmf_ss.str());

    //! bm_tn_fs : bm names for testing file stream
    std::ofstream bm_tn_fs;

    // if it doesn't exists, it creates it
    bm_tn_fs.open("../../code/cmd_field/test/testing_bitmaps.h",
        std::ofstream::out | std::ofstream::trunc);

    if (not bm_tn_fs) {
        std::cerr << "ERROR: can't open testing_bitmaps.h file" << std::endl;
        std::exit(EXIT_FAILURE);
    }

    // file comments:
    bm_tn_fs << "\n" << "// ** Bitmap Classes names for testing** //\n";
    bm_tn_fs << "\n" << "// Autogenerated in QDP Commands ** //\n";
    bm_tn_fs << "\n" << "// Manzano Software //\n";
    bm_tn_fs << "\n" << "#ifndef _MZN_TESTING_BITMAPS_";
    bm_tn_fs << "\n" << "#define _MZN_TESTING_BITMAPS_";
    bm_tn_fs << "\n\n" << "#include \"gtest/gtest.h\"";
    bm_tn_fs << "\n" << "#include \"cmd_field_bitmap.h\"";

    bm_tn_fs << "\n\nclass FixtureCmdFieldBitmaps : public ::testing::Test {";
    bm_tn_fs << "\npublic:";

    // loop over the bitmaps from the JSON
    // modifying the file for this type of bitmap

    for (auto bm_itr =
            bmf_json.begin();
            bm_itr != bmf_json.end(); ++bm_itr) {

        //! bm_name : bitmap name, i.e.: bm_cal_monitor_channel
        std::string bm_name = bm_itr.key();
        //! bm_classname : bm_name in camel calse, i.e.:BmCalMonitorChannel
        std::string bm_classname = make_classname_format(bm_name);
        //! mf_size : message field size. For CmdFieldBitmap, same as template
        //! parameter N, or number of bites in the underlaying std::bitset<N*8>

        int mf_size = bmf_json[bm_name.c_str()]["mf_size"];

        bm_tn_fs << "\n   mzn::" << bm_classname << " ";
        bm_tn_fs << bm_name << ";";
    }


    bm_tn_fs << "\n\n    virtual void SetUp() {";

    for (auto bm_itr =
            bmf_json.begin();
            bm_itr != bmf_json.end(); ++bm_itr) {

        //! bm_name : bitmap name, i.e.: bm_cal_monitor_channel
        std::string bm_name = bm_itr.key();

        std::cout << std::endl << "Processing : " << bm_name << std::endl;

        //! bm_classname : bm_name in camel calse, i.e.:BmCalMonitorChannel
        std::string bm_classname = make_classname_format(bm_name);
        //! mf_size : message field size. For CmdFieldBitmap, same as template
        //! parameter N, or number of bites in the underlaying std::bitset<N*8>
        int mf_size = bmf_json[bm_name.c_str()]["mf_size"];

        //! bm_T : bitmap class type, created from class template CmdFieldBitmap<N>
        std::string bm_T = "CmdFieldBitmap<" + std::to_string(mf_size) + ">";
        // bmf_code variables as defined above:

        int bmfn = bmf_json[bm_name.c_str()]["bm_fields"].size();

        // information originating in the digitizer (q)
        // does not need a setter

        std::string bm_originator =
            bmf_json[bm_name.c_str()]["bm_originator"];

        if (bm_originator != "q") {
            // basic setter

            for (int bmfi = 0; bmfi < bmfn; bmfi++) {

                std::string bmf_name =
                    bmf_json[bm_name.c_str()]["bm_fields"][bmfi]["bmf_name"];

                bm_tn_fs << "\n\n        ";
                // bm_tn_fs << bm_name << "." << bmf_name << "(" << 1 << ");";

            }

        }

        for (int bmfi = 0; bmfi < bmfn; bmfi++) {

            /*
            std::string bmf_name =
                bmf_json[bm_name.c_str()]["bm_fields"][bmfi]["bmf_name"];

            std::string var_name = "val_" + bm_name + "_" + bmf_name;

            bm_tn_fs << "\n\n        auto " << var_name << " =";
            bm_tn_fs << "\n            " << bm_name << "." << bmf_name << "();\n";

            if (bm_originator != "q") {
                bm_tn_fs << "\n        EXPECT_TRUE(" << var_name << ");";
            } else {
                bm_tn_fs << "\n        EXPECT_FALSE(" << var_name << ");";
            }
            */

        }

    } // end of iterator

    bm_tn_fs << "\n   }";
    bm_tn_fs << "\n};";
    bm_tn_fs << "\n#endif";
    bm_tn_fs.close();


    return 0;
};


